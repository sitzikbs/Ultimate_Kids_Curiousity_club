# ADR 005: YAML vs JSON for Show Blueprint Data

**Status**: ✅ Accepted  
**Date**: 2025-12-24  
**Deciders**: Team  
**Tags**: data-format, show-blueprint, human-editing

## Context

Show Blueprints contain both **human-authored creative content** (character personalities, world descriptions) and **machine-generated tracking data** (episode lists, concept coverage). We need to choose data formats that optimize for:

1. **Human editability**: Writers/creators need to easily edit character profiles and world descriptions
2. **Machine readability**: Python code needs to parse and validate data
3. **Version control**: Git diffs should be readable
4. **Comments**: Creative notes and guidance should be embeddable
5. **API compatibility**: Data should serialize cleanly for web dashboard (WP9)

## Decision

We will use a **hybrid YAML/JSON approach**:

### YAML for Human-Authored Content
- Show Blueprint files: `protagonist.yaml`, `world.yaml`, `characters/*.yaml`
- Prompt templates (Jinja2 with YAML frontmatter)
- Configuration files: `audio_config.yaml`, `voice_mapping.yaml`

### JSON for Machine-Generated Content  
- Episode state tracking: `concepts_covered.json`
- LLM outputs: `outline.json`, `segments.json`, `script.json`
- API responses from WP9 dashboard
- Episode metadata

## Rationale

### Why YAML for Show Blueprints?

**Human-Friendly Syntax**:
```yaml
# ✅ YAML - Clean, readable, commentable
name: "Oliver the Inventor"
age: 8
personality_traits:
  - "Curious: Always asks 'how' and 'why'"
  - "Energetic: Speaks faster when excited"
  - "Inventive: Sees everyday objects as gadget parts"
catchphrases:
  - "Let's figure it out!"
  - "Gizmos ready!"
core_motivation: >
  To understand how things work and build simple
  inventions that solve problems and help friends.
```

Compare to JSON:
```json
// ❌ JSON - Verbose, no comments in standard JSON
{
  "name": "Oliver the Inventor",
  "age": 8,
  "personality_traits": [
    "Curious: Always asks 'how' and 'why'",
    "Energetic: Speaks faster when excited",
    "Inventive: Sees everyday objects as gadget parts"
  ],
  "catchphrases": [
    "Let's figure it out!",
    "Gizmos ready!"
  ],
  "core_motivation": "To understand how things work and build simple inventions that solve problems and help friends."
}
```

**Advantages**:
- ✅ **Comments**: Critical for template guidance (`# This describes personality traits`)
- ✅ **Multi-line strings**: Natural `>` syntax for descriptions
- ✅ **No quote clutter**: Cleaner for creative writing
- ✅ **Existing templates**: Old repo has comprehensive YAML templates we can reuse
- ✅ **Pydantic support**: `pydantic-settings` handles YAML via `PyYAML`

**Disadvantages** (Mitigated):
- ⚠️ **Ambiguity**: Norway problem (`NO: false`), dates, booleans - **Mitigated by explicit Pydantic typing**
- ⚠️ **Slower parsing**: Negligible for small files (< 1ms difference)

### Why JSON for Generated Content?

**Machine-First Data**:
```json
{
  "episode_id": "ep_001",
  "status": "SCRIPT_GENERATION",
  "outline": {
    "beats": [...]
  },
  "metadata": {
    "generated_at": "2025-12-24T10:00:00Z",
    "llm_model": "gpt-4o",
    "cost": 0.023
  }
}
```

**Advantages**:
- ✅ **No ambiguity**: Strict typing, no parsing gotchas
- ✅ **Native Python**: Built-in `json` module, no dependencies
- ✅ **API standard**: RESTful APIs use JSON (WP9 dashboard)
- ✅ **Pydantic native**: `.model_dump_json()` is zero-overhead
- ✅ **Fast parsing**: Critical for large generated outputs

**Use cases**:
- Episode generation outputs (don't need human editing)
- Tracking files (`concepts_covered.json`)
- API request/response payloads
- Cache files

### Why Not TOML?

TOML was considered but rejected:
- ❌ **Complex nesting**: Awkward for deep hierarchies (e.g., character personality traits)
- ❌ **Less common**: Fewer libraries, less team familiarity
- ⚠️ **Better for config**: Good for `pyproject.toml` style, not creative content

## Implementation

### File Structure
```
data/shows/olivers_workshop/
├── protagonist.yaml          # ← YAML: Human edits personality, voice
├── world.yaml                # ← YAML: Human writes world descriptions
├── characters/
│   └── ruby_engineer.yaml    # ← YAML: Supporting character profiles
├── concepts_covered.json     # ← JSON: Tracking data (programmatic)
└── episodes/
    └── ep001/
        ├── concept.yaml      # ← YAML: Original episode concept (if authored)
        ├── outline.json      # ← JSON: Generated by LLM
        ├── segments.json     # ← JSON: Generated by LLM
        ├── script.json       # ← JSON: Generated by LLM
        └── final.mp3         # Final audio output
```

### Pydantic Integration

Both formats work seamlessly with Pydantic:

```python
# YAML Loading
import yaml
protagonist = Protagonist.model_validate(yaml.safe_load(file.read()))

# JSON Loading (native)
outline = StoryOutline.model_validate_json(file.read())

# Serialization
protagonist_yaml = yaml.dump(protagonist.model_dump())
outline_json = outline.model_dump_json(indent=2)
```

### Dashboard (WP9) Handling

The web dashboard can:
1. **Load YAML** for editing UI (convert to JSON in memory)
2. **Send/receive JSON** via REST API
3. **Save as YAML** when user edits Show Blueprint

```python
# API endpoint for Show Blueprint editing
@app.get("/api/shows/{show_id}/protagonist")
def get_protagonist(show_id: str):
    yaml_file = Path(f"data/shows/{show_id}/protagonist.yaml")
    protagonist = Protagonist.model_validate(yaml.safe_load(yaml_file.read_text()))
    return protagonist  # FastAPI auto-converts to JSON

@app.put("/api/shows/{show_id}/protagonist")
def update_protagonist(show_id: str, protagonist: Protagonist):
    yaml_file = Path(f"data/shows/{show_id}/protagonist.yaml")
    yaml_file.write_text(yaml.dump(protagonist.model_dump()))
    return {"status": "updated"}
```

## Consequences

### Positive
- ✅ **Optimized for use case**: YAML for humans, JSON for machines
- ✅ **Preserves old templates**: Can directly port YAML templates from old repo
- ✅ **Version control friendly**: Both formats diff well in git
- ✅ **No lock-in**: Can convert between formats using Pydantic
- ✅ **Best tooling**: YAML editors for creative work, JSON for APIs

### Negative
- ⚠️ **Two formats to maintain**: Need parsers for both
- ⚠️ **Team must learn YAML**: Not everyone knows YAML syntax
- ⚠️ **Potential inconsistency**: Need clear guidelines on when to use which

### Mitigation
- **Clear documentation**: ADR + examples in each WP
- **Template examples**: Provide annotated YAML templates in `docs/templates/`
- **Validation**: Pydantic ensures both formats produce identical models
- **Linting**: Add YAML linting to pre-commit hooks

## References

- Old repo templates: `old_repo/content_creation/series_blueprints/_templates/`
- WP1 (Foundation): ShowBlueprintManager loads both formats
- WP9 (Dashboard): API uses JSON, storage uses YAML
- [PyYAML docs](https://pyyaml.org/)
- [Pydantic YAML support](https://docs.pydantic.dev/latest/concepts/json/)

## Status

✅ **Accepted** - YAML for Show Blueprints (human), JSON for generated content (machine)
